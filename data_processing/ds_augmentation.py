import numpy as np
from scipy.stats import norm
import tensorflow as tf


def data_augmentation(datapoint, rng, data_augmentation_param):
    """
    Apply Data Augmentation to the dataset
    :param datapoint: consists of image, edge map, ...
    :param rng: random number generator to get the seed used by the data augmentation
    :param data_augmentation_param: parameters set in the config file
    :return: augmented datapoint
    """
    if data_augmentation_param["noise_std"] != 0:
        datapoint['in_img'] = tf.cast(datapoint['in_img'], tf.float32)
        datapoint['in_img'] = tf.keras.layers.GaussianNoise(data_augmentation_param["noise_std"])(datapoint['in_img'], training=True)
        datapoint['in_img'] = tf.clip_by_value(datapoint['in_img'], 0, 255.0)
        datapoint['in_img'] = tf.cast(datapoint['in_img'], tf.uint8)

    seed = rng.make_seeds(2)[0]
    datapoint['in_img'] = tf.image.stateless_random_contrast(datapoint['in_img'], data_augmentation_param["contrast_factor"], 1 / data_augmentation_param["contrast_factor"], seed)
    seed = rng.make_seeds(2)[0]
    datapoint['in_img'] = tf.image.stateless_random_brightness(datapoint['in_img'], data_augmentation_param["brightness"], seed)

    seed = rng.make_seeds(2)[0]
    datapoint['in_img'] = tf.image.stateless_random_hue(datapoint['in_img'], data_augmentation_param["hue"], seed)
    seed = rng.make_seeds(2)[0]
    datapoint['in_img'] = tf.image.stateless_random_saturation(datapoint['in_img'], data_augmentation_param["saturation"],
                                                            1 / data_augmentation_param["saturation"], seed)

    if data_augmentation_param["apply_spotlight"]:
        # convert to HSV
        datapoint['in_img'] = tf.image.convert_image_dtype(datapoint['in_img'], tf.float32)
        datapoint['in_img'] = tf.image.rgb_to_hsv(datapoint['in_img'])
    
        mask = tf.py_function(python_wrapper_spot_light,
                              inp=[datapoint['in_img'].shape, data_augmentation_param["spotlight_strength"]], Tout=tf.float32)
        datapoint['in_img'] = mask + datapoint['in_img']
        datapoint['in_img'] = tf.clip_by_value(datapoint['in_img'], 0.0, 1.0)
    
        # convert back to RGB of uint8: [0,255]
        datapoint['in_img'] = tf.image.hsv_to_rgb(datapoint['in_img'])
        datapoint['in_img'] = tf.image.convert_image_dtype(datapoint['in_img'], tf.uint8, saturate=True)
    
    if data_augmentation_param["apply_random_flip"]:
        seed = rng.make_seeds(2)[0]
        for key in datapoint.keys():
            datapoint[key] = tf.image.stateless_random_flip_left_right(datapoint[key], seed)
    
        seed = rng.make_seeds(2)[0]
        for key in datapoint.keys():
            datapoint[key] = tf.image.stateless_random_flip_up_down(datapoint[key], seed)

    return datapoint


def python_wrapper_spot_light(shape, strength_spot):
    """
    python wrapper needed by tensorflow in order to transform tensoflow tensors to numpy.
    :param shape: current shape of the image
    :param strength_spot: max added light (decrease saturation and increase value by this amount)
    :return: mask to sum up to the image in hsv color space
    """
    shape = shape.numpy()

    mask = np.zeros(shape)
    strength = np.random.uniform(-strength_spot, strength_spot)
    mask_raw = generate_spot_light_mask(mask_size=(shape[1], shape[0]))
    mask[:, :, 2] = strength * mask_raw
    mask[:, :, 1] = -strength * mask_raw
    return mask


def generate_spot_light_mask(mask_size, position=None, max_brightness=255, min_brightness=0, ):
    """
    Generate decayed light mask generated by spot light given position, direction. Multiple spotlights are accepted.
    Args:
        mask_size: tuple of integers (w, h) defining generated mask size
        position: list of tuple of integers (x, y) defining the center of spotlight light position,
                  which is the reference point during rotating
        max_brightness: integer that max brightness in the mask
        min_brightness: integer that min brightness in the mask
    Return:
        light_mask: ndarray in float type consisting value from max_brightness to min_brightness. If in 'linear' mode
                    minimum value could be smaller than given min_brightness.
    """
    if position is None:
        position = [(np.random.randint(0, mask_size[0]), np.random.randint(0, mask_size[1]))]
    mask = np.zeros(shape=(mask_size[1], mask_size[0]), dtype=np.float32)
    mu = np.sqrt(mask.shape[0] ** 2 + mask.shape[1] ** 2)
    dev = mu / 7
    mask = _decay_value_radically_norm_in_matrix(mask_size, position, max_brightness, min_brightness, dev)
    return mask


def _decay_value_radically_norm_in_matrix(mask_size, centers, max_value, min_value, dev):
    """
    _decay_value_radically_norm function in matrix format
    """
    center_prob = norm.pdf(0, 0, dev)
    x_value_rate = np.zeros((mask_size[1], mask_size[0]))
    for center in centers:
        coord_x = np.arange(mask_size[0])
        coord_y = np.arange(mask_size[1])
        xv, yv = np.meshgrid(coord_x, coord_y)
        dist_x = xv - center[0]
        dist_y = yv - center[1]
        dist = np.sqrt(np.power(dist_x, 2) + np.power(dist_y, 2))
        x_value_rate += norm.pdf(dist, 0, dev) / center_prob
    mask = x_value_rate * (max_value - min_value) + min_value
    mask[mask > 255] = 255
    return mask / 255.0
